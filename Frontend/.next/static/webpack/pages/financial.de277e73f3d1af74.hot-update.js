/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/financial",{

/***/ "./pages/financial.js":
/*!****************************!*\
  !*** ./pages/financial.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// import React, { useEffect, useState, useRef } from 'react';\n// import { Bar, Pie } from 'react-chartjs-2';\n// import {\n//   Chart as ChartJS,\n//   BarElement,\n//   ArcElement,\n//   CategoryScale,\n//   LinearScale,\n//   Tooltip,\n//   Legend\n// } from 'chart.js';\n// import jsPDF from 'jspdf';\n// import autoTable from 'jspdf-autotable';\n// import html2canvas from 'html2canvas';\n// import styles from '../styles/financial.module.css';\n// import ChartDataLabels from 'chartjs-plugin-datalabels';\n// ChartJS.register(BarElement, ArcElement, CategoryScale, LinearScale, Tooltip, Legend, ChartDataLabels);\n// export default function FinancialPage() {\n//   const [data, setData] = useState([]);\n//   const revenueChartRef = useRef(null);\n//   const expenseChartRef = useRef(null);\n//   const assetsChartRef = useRef(null);\n//   useEffect(() => {\n//     async function fetchData() {\n//       const response = await fetch('/netcare_financial_data.json');\n//       const json = await response.json();\n//       if (Array.isArray(json)) {\n//         setData(json);\n//       } else {\n//         console.error(\"Data received is not an array:\", json);\n//       }\n//     }\n//     fetchData();\n//   }, []);\n//   if (!Array.isArray(data) || data.length === 0) return <p>Loading data...</p>;\n//   // Extract data for charts\n//   const revenueLabels = data.map((item) => item['Revenue Source']);\n//   const expenseLabels = data.map((item) => item['Expense Category']).filter(Boolean);\n//   const assetsLabels = data.map((item) => item['Assets']).filter(Boolean);\n//   const revenue2020 = data.map((item) => parseFloat(item['2020']) || 0);\n//   const revenue2021 = data.map((item) => parseFloat(item['2021']) || 0);\n//   const revenue2022 = data.map((item) => parseFloat(item['2022']) || 0);\n//   const expenses2022 = data.map((item) => parseFloat(item['2022 Expenses']) || 0).filter((value) => !isNaN(value));\n//   const assets2020 = data.map((item) => parseFloat(item['2020 Assets']) || 0).filter((value) => !isNaN(value));\n//   const assets2021 = data.map((item) => parseFloat(item['2021 Assets']) || 0).filter((value) => !isNaN(value));\n//   const assets2022 = data.map((item) => parseFloat(item['2022 Assets']) || 0).filter((value) => !isNaN(value));\n//   // Bar chart data for revenue comparison across years\n//   const revenueData = {\n//     labels: revenueLabels,\n//     datasets: [\n//       { label: '2020 Revenue', data: revenue2020, backgroundColor: 'rgba(75, 192, 192, 0.6)' },\n//       { label: '2021 Revenue', data: revenue2021, backgroundColor: 'rgba(153, 102, 255, 0.6)' },\n//       { label: '2022 Revenue', data: revenue2022, backgroundColor: 'rgba(255, 159, 64, 0.6)' },\n//     ],\n//   };\n//   // Disable datalabels for revenue and assets charts\n//   const barOptions = {\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     plugins: {\n//       datalabels: {\n//         display: false, // Hide datalabels on bar charts\n//       },\n//     },\n//   };\n//   // Pie chart data for 2022 expenses with percentage labels\n// const expenseData2022 = {\n//     labels: expenseLabels,\n//     datasets: [\n//       {\n//         label: '2022 Expenses',\n//         data: expenses2022,\n//         backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],\n//       },\n//     ],\n//   };\n//   const expenseOptions = {\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     plugins: {\n//       tooltip: {\n//         callbacks: {\n//           label: (tooltipItem) => {\n//             const total = expenses2022.reduce((acc, value) => acc + value, 0);\n//             const value = tooltipItem.raw;\n//             const percentage = ((value / total) * 100).toFixed(2);\n//             return `${tooltipItem.label}: $${value} (${percentage}%)`;\n//           },\n//         },\n//       },\n//       datalabels: {\n//         color: '#000',\n//         formatter: (value, context) => {\n//           const total = context.chart.data.datasets[0].data.reduce((acc, val) => acc + val, 0);\n//           const percentage = ((value / total) * 100).toFixed(1) + '%';\n//           return percentage;\n//         },\n//         anchor: 'end',\n//         align: 'start',\n//         offset: 10,\n//         backgroundColor: (context) => context.dataset.backgroundColor[context.dataIndex],\n//         padding: { top: 2, bottom: 2, left: 8, right: 8 }\n//       },\n//     },\n//   };\n//   // Bar chart data for assets comparison across years\n//   const assetsData = {\n//     labels: assetsLabels,\n//     datasets: [\n//       { label: '2020 Assets', data: assets2020, backgroundColor: 'rgba(255, 99, 132, 0.6)' },\n//       { label: '2021 Assets', data: assets2021, backgroundColor: 'rgba(54, 162, 235, 0.6)' },\n//       { label: '2022 Assets', data: assets2022, backgroundColor: 'rgba(255, 206, 86, 0.6)' },\n//     ],\n//   };\n//   const generateReport = async () => {\n//     const doc = new jsPDF(\"p\", \"pt\", \"a4\");\n//     // First Page - Table of Financial Data\n//     doc.setFontSize(18);\n//     doc.text(\"2022 Financial Overview\", 40, 40);\n//     // Revenue Table Data\n//     const revenueRows = data.slice(0, 9).map((item) => [\n//       item['Revenue Source'],\n//       `$${item['2020']}`,\n//       `$${item['2021']}`,\n//       `$${item['2022']}`\n//     ]);\n//     // Expense Table Data\n//     const expenseRows = data.slice(0, 5).map((item) => [\n//       item['Expense Category'],\n//       `$${item['2020 Expenses']}`,\n//       `$${item['2021 Expenses']}`,\n//       `$${item['2022 Expenses']}`\n//     ]);\n//     // Assets Table Data - Filter out rows with undefined or missing asset values\n//     const assetsRows = data\n//       .filter((item) => item['Assets'] && item['2020 Assets'] && item['2021 Assets'] && item['2022 Assets'])\n//       .map((item) => [\n//         item['Assets'],\n//         `$${item['2020 Assets']}`,\n//         `$${item['2021 Assets']}`,\n//         `$${item['2022 Assets']}`\n//       ]);\n//     // Add Revenue Table\n//     doc.setFontSize(14);\n//     doc.text(\"Revenue\", 40, 70);\n//     autoTable(doc, {\n//       startY: 90,\n//       head: [['Source', '2020', '2021', '2022']],\n//       body: revenueRows,\n//       theme: 'grid',\n//       styles: { fontSize: 10 },\n//       headStyles: { fillColor: [41, 128, 185] },\n//       margin: { left: 40, right: 40 },\n//     });\n//     // Add Expense Table\n//     const expenseStartY = doc.autoTable.previous.finalY + 20;\n//     doc.text(\"Expenses\", 40, expenseStartY);\n//     autoTable(doc, {\n//       startY: expenseStartY + 20,\n//       head: [['Category', '2020', '2021', '2022']],\n//       body: expenseRows,\n//       theme: 'grid',\n//       styles: { fontSize: 10 },\n//       headStyles: { fillColor: [41, 128, 185] },\n//       margin: { left: 40, right: 40 },\n//     });\n//     // Add Assets Table\n//     const assetsStartY = doc.autoTable.previous.finalY + 20;\n//     doc.text(\"Assets\", 40, assetsStartY);\n//     autoTable(doc, {\n//       startY: assetsStartY + 20,\n//       head: [['Asset Type', '2020', '2021', '2022']],\n//       body: assetsRows,\n//       theme: 'grid',\n//       styles: { fontSize: 10 },\n//       headStyles: { fillColor: [41, 128, 185] },\n//       margin: { left: 40, right: 40 },\n//     });\n//     // Second Page - Charts\n//     doc.addPage();\n//     doc.setFontSize(18);\n//     doc.text(\"2022 Financial Overview - Charts\", 40, 40);\n//     // Capture and add revenue chart\n//     const revenueCanvas = await html2canvas(revenueChartRef.current);\n//     const revenueImage = revenueCanvas.toDataURL(\"image/png\");\n//     const revenueWidth = 500;\n//     const revenueAspectRatio = revenueCanvas.width / revenueCanvas.height;\n//     const revenueHeight = revenueWidth / revenueAspectRatio;\n//     doc.addImage(revenueImage, \"PNG\", 40, 80, revenueWidth, revenueHeight);\n//     // Capture and add expense chart\n//     const expenseCanvas = await html2canvas(expenseChartRef.current);\n//     const expenseImage = expenseCanvas.toDataURL(\"image/png\");\n//     const expenseWidth = 500;\n//     const expenseAspectRatio = expenseCanvas.width / expenseCanvas.height;\n//     const expenseHeight = expenseWidth / expenseAspectRatio;\n//     doc.addImage(expenseImage, \"PNG\", 40, 480, expenseWidth, expenseHeight);\n//     // Capture and add assets chart\n//     const assetsCanvas = await html2canvas(assetsChartRef.current);\n//     const assetsImage = assetsCanvas.toDataURL(\"image/png\");\n//     const assetsWidth = 500;\n//     const assetsAspectRatio = assetsCanvas.width / assetsCanvas.height;\n//     const assetsHeight = assetsWidth / assetsAspectRatio;\n//     doc.addImage(assetsImage, \"PNG\", 40, 880, assetsWidth, assetsHeight);\n//     // Save the PDF\n//     doc.save(\"financial_report_2022.pdf\");\n//   };\n//   return (\n//     <div className={styles.container}>\n//       <h1 className={styles.header}>Financial Dashboard</h1>\n//       <div className={styles.summaryContainer}>\n//         <div>\n//           <h3>Total Revenue (2022)</h3>\n//           <p className={styles.revenueText}>${data[8]?.['2022']}</p>\n//         </div>\n//         <div>\n//           <h3>Total Expenses (2022)</h3>\n//           <p className={styles.expensesText}>${data[4]?.['2022 Expenses']}</p>\n//         </div>\n//       </div>\n//       {/* Revenue Chart */}\n//       <section>\n//         <h2 className={styles.chartSection}>Revenue Comparison by Year</h2>\n//         <div ref={revenueChartRef} className={styles.chartContainer}>\n//           <Bar data={revenueData} options={barOptions} />\n//         </div>\n//       </section>\n//       {/* Expenses Chart */}\n//       <section style={{ marginTop: '2rem' }}>\n//         <h2 className={styles.chartSection}>2022 Expenses Distribution</h2>\n//         <div ref={expenseChartRef} className={styles.chartContainer}>\n//             <Pie data={expenseData2022} options={expenseOptions} />\n//         </div>\n//       </section>\n//       {/* Assets Chart */}\n//       <section style={{ marginTop: '2rem' }}>\n//         <h2 className={styles.chartSection}>Assets Comparison by Year</h2>\n//         <div ref={assetsChartRef} className={styles.chartContainer}>\n//           <Bar data={assetsData} options={barOptions} />\n//         </div>\n//       </section>\n//       {/* Generate Report Button */}\n//       <button onClick={generateReport} className={styles.generateReportButton}>\n//         Generate Report\n//       </button>\n//     </div>\n//   );\n// }\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ2hCLDBDQUEwQztBQUMxQyx1RUFBdUU7QUFDdkUsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQiwyQ0FBMkM7QUFDM0MsaUZBQWlGO0FBQ2pGLGlCQUFpQjtBQUNqQixlQUFlO0FBRWYsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQiw4RUFBOEU7QUFDOUUsd0VBQXdFO0FBQ3hFLDREQUE0RDtBQUM1RCxpQkFBaUI7QUFDakIsbUJBQW1CO0FBRW5CLCtCQUErQjtBQUMvQixnREFBZ0Q7QUFDaEQsOEVBQThFO0FBQzlFLHdFQUF3RTtBQUN4RSxzRUFBc0U7QUFDdEUsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUduQiw2QkFBNkI7QUFDN0IsZ0RBQWdEO0FBQ2hELDZFQUE2RTtBQUM3RSx1RUFBdUU7QUFDdkUsMkRBQTJEO0FBQzNELGlCQUFpQjtBQUNqQixtQkFBbUI7QUFFbkIsdUNBQXVDO0FBQ3ZDLGtGQUFrRjtBQUNsRiwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixPQUFPO0FBQ1AsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3BhZ2VzL2ZpbmFuY2lhbC5qcz84MDNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XHJcbi8vIGltcG9ydCB7IEJhciwgUGllIH0gZnJvbSAncmVhY3QtY2hhcnRqcy0yJztcclxuLy8gaW1wb3J0IHtcclxuLy8gICBDaGFydCBhcyBDaGFydEpTLFxyXG4vLyAgIEJhckVsZW1lbnQsXHJcbi8vICAgQXJjRWxlbWVudCxcclxuLy8gICBDYXRlZ29yeVNjYWxlLFxyXG4vLyAgIExpbmVhclNjYWxlLFxyXG4vLyAgIFRvb2x0aXAsXHJcbi8vICAgTGVnZW5kXHJcbi8vIH0gZnJvbSAnY2hhcnQuanMnO1xyXG4vLyBpbXBvcnQganNQREYgZnJvbSAnanNwZGYnO1xyXG4vLyBpbXBvcnQgYXV0b1RhYmxlIGZyb20gJ2pzcGRmLWF1dG90YWJsZSc7XHJcbi8vIGltcG9ydCBodG1sMmNhbnZhcyBmcm9tICdodG1sMmNhbnZhcyc7XHJcbi8vIGltcG9ydCBzdHlsZXMgZnJvbSAnLi4vc3R5bGVzL2ZpbmFuY2lhbC5tb2R1bGUuY3NzJztcclxuLy8gaW1wb3J0IENoYXJ0RGF0YUxhYmVscyBmcm9tICdjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzJztcclxuXHJcbi8vIENoYXJ0SlMucmVnaXN0ZXIoQmFyRWxlbWVudCwgQXJjRWxlbWVudCwgQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIFRvb2x0aXAsIExlZ2VuZCwgQ2hhcnREYXRhTGFiZWxzKTtcclxuXHJcbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZpbmFuY2lhbFBhZ2UoKSB7XHJcbi8vICAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGUoW10pO1xyXG4vLyAgIGNvbnN0IHJldmVudWVDaGFydFJlZiA9IHVzZVJlZihudWxsKTtcclxuLy8gICBjb25zdCBleHBlbnNlQ2hhcnRSZWYgPSB1c2VSZWYobnVsbCk7XHJcbi8vICAgY29uc3QgYXNzZXRzQ2hhcnRSZWYgPSB1c2VSZWYobnVsbCk7XHJcblxyXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbi8vICAgICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XHJcbi8vICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9uZXRjYXJlX2ZpbmFuY2lhbF9kYXRhLmpzb24nKTtcclxuLy8gICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuXHJcbi8vICAgICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbi8vICAgICAgICAgc2V0RGF0YShqc29uKTtcclxuLy8gICAgICAgfSBlbHNlIHtcclxuLy8gICAgICAgICBjb25zb2xlLmVycm9yKFwiRGF0YSByZWNlaXZlZCBpcyBub3QgYW4gYXJyYXk6XCIsIGpzb24pO1xyXG4vLyAgICAgICB9XHJcbi8vICAgICB9XHJcbi8vICAgICBmZXRjaERhdGEoKTtcclxuLy8gICB9LCBbXSk7XHJcblxyXG4vLyAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDxwPkxvYWRpbmcgZGF0YS4uLjwvcD47XHJcblxyXG4vLyAgIC8vIEV4dHJhY3QgZGF0YSBmb3IgY2hhcnRzXHJcbi8vICAgY29uc3QgcmV2ZW51ZUxhYmVscyA9IGRhdGEubWFwKChpdGVtKSA9PiBpdGVtWydSZXZlbnVlIFNvdXJjZSddKTtcclxuLy8gICBjb25zdCBleHBlbnNlTGFiZWxzID0gZGF0YS5tYXAoKGl0ZW0pID0+IGl0ZW1bJ0V4cGVuc2UgQ2F0ZWdvcnknXSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4vLyAgIGNvbnN0IGFzc2V0c0xhYmVscyA9IGRhdGEubWFwKChpdGVtKSA9PiBpdGVtWydBc3NldHMnXSkuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuLy8gICBjb25zdCByZXZlbnVlMjAyMCA9IGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZUZsb2F0KGl0ZW1bJzIwMjAnXSkgfHwgMCk7XHJcbi8vICAgY29uc3QgcmV2ZW51ZTIwMjEgPSBkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VGbG9hdChpdGVtWycyMDIxJ10pIHx8IDApO1xyXG4vLyAgIGNvbnN0IHJldmVudWUyMDIyID0gZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlRmxvYXQoaXRlbVsnMjAyMiddKSB8fCAwKTtcclxuXHJcbi8vICAgY29uc3QgZXhwZW5zZXMyMDIyID0gZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlRmxvYXQoaXRlbVsnMjAyMiBFeHBlbnNlcyddKSB8fCAwKS5maWx0ZXIoKHZhbHVlKSA9PiAhaXNOYU4odmFsdWUpKTtcclxuLy8gICBjb25zdCBhc3NldHMyMDIwID0gZGF0YS5tYXAoKGl0ZW0pID0+IHBhcnNlRmxvYXQoaXRlbVsnMjAyMCBBc3NldHMnXSkgfHwgMCkuZmlsdGVyKCh2YWx1ZSkgPT4gIWlzTmFOKHZhbHVlKSk7XHJcbi8vICAgY29uc3QgYXNzZXRzMjAyMSA9IGRhdGEubWFwKChpdGVtKSA9PiBwYXJzZUZsb2F0KGl0ZW1bJzIwMjEgQXNzZXRzJ10pIHx8IDApLmZpbHRlcigodmFsdWUpID0+ICFpc05hTih2YWx1ZSkpO1xyXG4vLyAgIGNvbnN0IGFzc2V0czIwMjIgPSBkYXRhLm1hcCgoaXRlbSkgPT4gcGFyc2VGbG9hdChpdGVtWycyMDIyIEFzc2V0cyddKSB8fCAwKS5maWx0ZXIoKHZhbHVlKSA9PiAhaXNOYU4odmFsdWUpKTtcclxuXHJcbi8vICAgLy8gQmFyIGNoYXJ0IGRhdGEgZm9yIHJldmVudWUgY29tcGFyaXNvbiBhY3Jvc3MgeWVhcnNcclxuLy8gICBjb25zdCByZXZlbnVlRGF0YSA9IHtcclxuLy8gICAgIGxhYmVsczogcmV2ZW51ZUxhYmVscyxcclxuLy8gICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgIHsgbGFiZWw6ICcyMDIwIFJldmVudWUnLCBkYXRhOiByZXZlbnVlMjAyMCwgYmFja2dyb3VuZENvbG9yOiAncmdiYSg3NSwgMTkyLCAxOTIsIDAuNiknIH0sXHJcbi8vICAgICAgIHsgbGFiZWw6ICcyMDIxIFJldmVudWUnLCBkYXRhOiByZXZlbnVlMjAyMSwgYmFja2dyb3VuZENvbG9yOiAncmdiYSgxNTMsIDEwMiwgMjU1LCAwLjYpJyB9LFxyXG4vLyAgICAgICB7IGxhYmVsOiAnMjAyMiBSZXZlbnVlJywgZGF0YTogcmV2ZW51ZTIwMjIsIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAxNTksIDY0LCAwLjYpJyB9LFxyXG4vLyAgICAgXSxcclxuLy8gICB9O1xyXG5cclxuLy8gICAvLyBEaXNhYmxlIGRhdGFsYWJlbHMgZm9yIHJldmVudWUgYW5kIGFzc2V0cyBjaGFydHNcclxuLy8gICBjb25zdCBiYXJPcHRpb25zID0ge1xyXG4vLyAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcclxuLy8gICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxyXG4vLyAgICAgcGx1Z2luczoge1xyXG4vLyAgICAgICBkYXRhbGFiZWxzOiB7XHJcbi8vICAgICAgICAgZGlzcGxheTogZmFsc2UsIC8vIEhpZGUgZGF0YWxhYmVscyBvbiBiYXIgY2hhcnRzXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICB9LFxyXG4vLyAgIH07XHJcblxyXG4vLyAgIC8vIFBpZSBjaGFydCBkYXRhIGZvciAyMDIyIGV4cGVuc2VzIHdpdGggcGVyY2VudGFnZSBsYWJlbHNcclxuLy8gY29uc3QgZXhwZW5zZURhdGEyMDIyID0ge1xyXG4vLyAgICAgbGFiZWxzOiBleHBlbnNlTGFiZWxzLFxyXG4vLyAgICAgZGF0YXNldHM6IFtcclxuLy8gICAgICAge1xyXG4vLyAgICAgICAgIGxhYmVsOiAnMjAyMiBFeHBlbnNlcycsXHJcbi8vICAgICAgICAgZGF0YTogZXhwZW5zZXMyMDIyLFxyXG4vLyAgICAgICAgIGJhY2tncm91bmRDb2xvcjogWycjRkY2Mzg0JywgJyMzNkEyRUInLCAnI0ZGQ0U1NicsICcjNEJDMEMwJywgJyM5OTY2RkYnXSxcclxuLy8gICAgICAgfSxcclxuLy8gICAgIF0sXHJcbi8vICAgfTtcclxuICBcclxuLy8gICBjb25zdCBleHBlbnNlT3B0aW9ucyA9IHtcclxuLy8gICAgIHJlc3BvbnNpdmU6IHRydWUsXHJcbi8vICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcclxuLy8gICAgIHBsdWdpbnM6IHtcclxuLy8gICAgICAgdG9vbHRpcDoge1xyXG4vLyAgICAgICAgIGNhbGxiYWNrczoge1xyXG4vLyAgICAgICAgICAgbGFiZWw6ICh0b29sdGlwSXRlbSkgPT4ge1xyXG4vLyAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IGV4cGVuc2VzMjAyMi5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IGFjYyArIHZhbHVlLCAwKTtcclxuLy8gICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5yYXc7XHJcbi8vICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAoKHZhbHVlIC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpO1xyXG4vLyAgICAgICAgICAgICByZXR1cm4gYCR7dG9vbHRpcEl0ZW0ubGFiZWx9OiAkJHt2YWx1ZX0gKCR7cGVyY2VudGFnZX0lKWA7XHJcbi8vICAgICAgICAgICB9LFxyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgIH0sXHJcbi8vICAgICAgIGRhdGFsYWJlbHM6IHtcclxuLy8gICAgICAgICBjb2xvcjogJyMwMDAnLFxyXG4vLyAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlLCBjb250ZXh0KSA9PiB7XHJcbi8vICAgICAgICAgICBjb25zdCB0b3RhbCA9IGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCwgMCk7XHJcbi8vICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKCh2YWx1ZSAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgxKSArICclJztcclxuLy8gICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlO1xyXG4vLyAgICAgICAgIH0sXHJcbi8vICAgICAgICAgYW5jaG9yOiAnZW5kJyxcclxuLy8gICAgICAgICBhbGlnbjogJ3N0YXJ0JyxcclxuLy8gICAgICAgICBvZmZzZXQ6IDEwLFxyXG4vLyAgICAgICAgIGJhY2tncm91bmRDb2xvcjogKGNvbnRleHQpID0+IGNvbnRleHQuZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3JbY29udGV4dC5kYXRhSW5kZXhdLFxyXG4vLyAgICAgICAgIHBhZGRpbmc6IHsgdG9wOiAyLCBib3R0b206IDIsIGxlZnQ6IDgsIHJpZ2h0OiA4IH1cclxuLy8gICAgICAgfSxcclxuLy8gICAgIH0sXHJcbi8vICAgfTtcclxuICBcclxuXHJcbi8vICAgLy8gQmFyIGNoYXJ0IGRhdGEgZm9yIGFzc2V0cyBjb21wYXJpc29uIGFjcm9zcyB5ZWFyc1xyXG4vLyAgIGNvbnN0IGFzc2V0c0RhdGEgPSB7XHJcbi8vICAgICBsYWJlbHM6IGFzc2V0c0xhYmVscyxcclxuLy8gICAgIGRhdGFzZXRzOiBbXHJcbi8vICAgICAgIHsgbGFiZWw6ICcyMDIwIEFzc2V0cycsIGRhdGE6IGFzc2V0czIwMjAsIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCA5OSwgMTMyLCAwLjYpJyB9LFxyXG4vLyAgICAgICB7IGxhYmVsOiAnMjAyMSBBc3NldHMnLCBkYXRhOiBhc3NldHMyMDIxLCBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDU0LCAxNjIsIDIzNSwgMC42KScgfSxcclxuLy8gICAgICAgeyBsYWJlbDogJzIwMjIgQXNzZXRzJywgZGF0YTogYXNzZXRzMjAyMiwgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDIwNiwgODYsIDAuNiknIH0sXHJcbi8vICAgICBdLFxyXG4vLyAgIH07XHJcblxyXG4vLyAgIGNvbnN0IGdlbmVyYXRlUmVwb3J0ID0gYXN5bmMgKCkgPT4ge1xyXG4vLyAgICAgY29uc3QgZG9jID0gbmV3IGpzUERGKFwicFwiLCBcInB0XCIsIFwiYTRcIik7XHJcbiAgXHJcbi8vICAgICAvLyBGaXJzdCBQYWdlIC0gVGFibGUgb2YgRmluYW5jaWFsIERhdGFcclxuLy8gICAgIGRvYy5zZXRGb250U2l6ZSgxOCk7XHJcbi8vICAgICBkb2MudGV4dChcIjIwMjIgRmluYW5jaWFsIE92ZXJ2aWV3XCIsIDQwLCA0MCk7XHJcbiAgXHJcbi8vICAgICAvLyBSZXZlbnVlIFRhYmxlIERhdGFcclxuLy8gICAgIGNvbnN0IHJldmVudWVSb3dzID0gZGF0YS5zbGljZSgwLCA5KS5tYXAoKGl0ZW0pID0+IFtcclxuLy8gICAgICAgaXRlbVsnUmV2ZW51ZSBTb3VyY2UnXSxcclxuLy8gICAgICAgYCQke2l0ZW1bJzIwMjAnXX1gLFxyXG4vLyAgICAgICBgJCR7aXRlbVsnMjAyMSddfWAsXHJcbi8vICAgICAgIGAkJHtpdGVtWycyMDIyJ119YFxyXG4vLyAgICAgXSk7XHJcbiAgXHJcbi8vICAgICAvLyBFeHBlbnNlIFRhYmxlIERhdGFcclxuLy8gICAgIGNvbnN0IGV4cGVuc2VSb3dzID0gZGF0YS5zbGljZSgwLCA1KS5tYXAoKGl0ZW0pID0+IFtcclxuLy8gICAgICAgaXRlbVsnRXhwZW5zZSBDYXRlZ29yeSddLFxyXG4vLyAgICAgICBgJCR7aXRlbVsnMjAyMCBFeHBlbnNlcyddfWAsXHJcbi8vICAgICAgIGAkJHtpdGVtWycyMDIxIEV4cGVuc2VzJ119YCxcclxuLy8gICAgICAgYCQke2l0ZW1bJzIwMjIgRXhwZW5zZXMnXX1gXHJcbi8vICAgICBdKTtcclxuICBcclxuLy8gICAgIC8vIEFzc2V0cyBUYWJsZSBEYXRhIC0gRmlsdGVyIG91dCByb3dzIHdpdGggdW5kZWZpbmVkIG9yIG1pc3NpbmcgYXNzZXQgdmFsdWVzXHJcbi8vICAgICBjb25zdCBhc3NldHNSb3dzID0gZGF0YVxyXG4vLyAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtWydBc3NldHMnXSAmJiBpdGVtWycyMDIwIEFzc2V0cyddICYmIGl0ZW1bJzIwMjEgQXNzZXRzJ10gJiYgaXRlbVsnMjAyMiBBc3NldHMnXSlcclxuLy8gICAgICAgLm1hcCgoaXRlbSkgPT4gW1xyXG4vLyAgICAgICAgIGl0ZW1bJ0Fzc2V0cyddLFxyXG4vLyAgICAgICAgIGAkJHtpdGVtWycyMDIwIEFzc2V0cyddfWAsXHJcbi8vICAgICAgICAgYCQke2l0ZW1bJzIwMjEgQXNzZXRzJ119YCxcclxuLy8gICAgICAgICBgJCR7aXRlbVsnMjAyMiBBc3NldHMnXX1gXHJcbi8vICAgICAgIF0pO1xyXG4gIFxyXG4vLyAgICAgLy8gQWRkIFJldmVudWUgVGFibGVcclxuLy8gICAgIGRvYy5zZXRGb250U2l6ZSgxNCk7XHJcbi8vICAgICBkb2MudGV4dChcIlJldmVudWVcIiwgNDAsIDcwKTtcclxuLy8gICAgIGF1dG9UYWJsZShkb2MsIHtcclxuLy8gICAgICAgc3RhcnRZOiA5MCxcclxuLy8gICAgICAgaGVhZDogW1snU291cmNlJywgJzIwMjAnLCAnMjAyMScsICcyMDIyJ11dLFxyXG4vLyAgICAgICBib2R5OiByZXZlbnVlUm93cyxcclxuLy8gICAgICAgdGhlbWU6ICdncmlkJyxcclxuLy8gICAgICAgc3R5bGVzOiB7IGZvbnRTaXplOiAxMCB9LFxyXG4vLyAgICAgICBoZWFkU3R5bGVzOiB7IGZpbGxDb2xvcjogWzQxLCAxMjgsIDE4NV0gfSxcclxuLy8gICAgICAgbWFyZ2luOiB7IGxlZnQ6IDQwLCByaWdodDogNDAgfSxcclxuLy8gICAgIH0pO1xyXG4gIFxyXG4vLyAgICAgLy8gQWRkIEV4cGVuc2UgVGFibGVcclxuLy8gICAgIGNvbnN0IGV4cGVuc2VTdGFydFkgPSBkb2MuYXV0b1RhYmxlLnByZXZpb3VzLmZpbmFsWSArIDIwO1xyXG4vLyAgICAgZG9jLnRleHQoXCJFeHBlbnNlc1wiLCA0MCwgZXhwZW5zZVN0YXJ0WSk7XHJcbi8vICAgICBhdXRvVGFibGUoZG9jLCB7XHJcbi8vICAgICAgIHN0YXJ0WTogZXhwZW5zZVN0YXJ0WSArIDIwLFxyXG4vLyAgICAgICBoZWFkOiBbWydDYXRlZ29yeScsICcyMDIwJywgJzIwMjEnLCAnMjAyMiddXSxcclxuLy8gICAgICAgYm9keTogZXhwZW5zZVJvd3MsXHJcbi8vICAgICAgIHRoZW1lOiAnZ3JpZCcsXHJcbi8vICAgICAgIHN0eWxlczogeyBmb250U2l6ZTogMTAgfSxcclxuLy8gICAgICAgaGVhZFN0eWxlczogeyBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdIH0sXHJcbi8vICAgICAgIG1hcmdpbjogeyBsZWZ0OiA0MCwgcmlnaHQ6IDQwIH0sXHJcbi8vICAgICB9KTtcclxuICBcclxuLy8gICAgIC8vIEFkZCBBc3NldHMgVGFibGVcclxuLy8gICAgIGNvbnN0IGFzc2V0c1N0YXJ0WSA9IGRvYy5hdXRvVGFibGUucHJldmlvdXMuZmluYWxZICsgMjA7XHJcbi8vICAgICBkb2MudGV4dChcIkFzc2V0c1wiLCA0MCwgYXNzZXRzU3RhcnRZKTtcclxuLy8gICAgIGF1dG9UYWJsZShkb2MsIHtcclxuLy8gICAgICAgc3RhcnRZOiBhc3NldHNTdGFydFkgKyAyMCxcclxuLy8gICAgICAgaGVhZDogW1snQXNzZXQgVHlwZScsICcyMDIwJywgJzIwMjEnLCAnMjAyMiddXSxcclxuLy8gICAgICAgYm9keTogYXNzZXRzUm93cyxcclxuLy8gICAgICAgdGhlbWU6ICdncmlkJyxcclxuLy8gICAgICAgc3R5bGVzOiB7IGZvbnRTaXplOiAxMCB9LFxyXG4vLyAgICAgICBoZWFkU3R5bGVzOiB7IGZpbGxDb2xvcjogWzQxLCAxMjgsIDE4NV0gfSxcclxuLy8gICAgICAgbWFyZ2luOiB7IGxlZnQ6IDQwLCByaWdodDogNDAgfSxcclxuLy8gICAgIH0pO1xyXG4gIFxyXG4vLyAgICAgLy8gU2Vjb25kIFBhZ2UgLSBDaGFydHNcclxuLy8gICAgIGRvYy5hZGRQYWdlKCk7XHJcbi8vICAgICBkb2Muc2V0Rm9udFNpemUoMTgpO1xyXG4vLyAgICAgZG9jLnRleHQoXCIyMDIyIEZpbmFuY2lhbCBPdmVydmlldyAtIENoYXJ0c1wiLCA0MCwgNDApO1xyXG4gIFxyXG4vLyAgICAgLy8gQ2FwdHVyZSBhbmQgYWRkIHJldmVudWUgY2hhcnRcclxuLy8gICAgIGNvbnN0IHJldmVudWVDYW52YXMgPSBhd2FpdCBodG1sMmNhbnZhcyhyZXZlbnVlQ2hhcnRSZWYuY3VycmVudCk7XHJcbi8vICAgICBjb25zdCByZXZlbnVlSW1hZ2UgPSByZXZlbnVlQ2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuLy8gICAgIGNvbnN0IHJldmVudWVXaWR0aCA9IDUwMDtcclxuLy8gICAgIGNvbnN0IHJldmVudWVBc3BlY3RSYXRpbyA9IHJldmVudWVDYW52YXMud2lkdGggLyByZXZlbnVlQ2FudmFzLmhlaWdodDtcclxuLy8gICAgIGNvbnN0IHJldmVudWVIZWlnaHQgPSByZXZlbnVlV2lkdGggLyByZXZlbnVlQXNwZWN0UmF0aW87XHJcbi8vICAgICBkb2MuYWRkSW1hZ2UocmV2ZW51ZUltYWdlLCBcIlBOR1wiLCA0MCwgODAsIHJldmVudWVXaWR0aCwgcmV2ZW51ZUhlaWdodCk7XHJcbiAgXHJcbi8vICAgICAvLyBDYXB0dXJlIGFuZCBhZGQgZXhwZW5zZSBjaGFydFxyXG4vLyAgICAgY29uc3QgZXhwZW5zZUNhbnZhcyA9IGF3YWl0IGh0bWwyY2FudmFzKGV4cGVuc2VDaGFydFJlZi5jdXJyZW50KTtcclxuLy8gICAgIGNvbnN0IGV4cGVuc2VJbWFnZSA9IGV4cGVuc2VDYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xyXG4vLyAgICAgY29uc3QgZXhwZW5zZVdpZHRoID0gNTAwO1xyXG4vLyAgICAgY29uc3QgZXhwZW5zZUFzcGVjdFJhdGlvID0gZXhwZW5zZUNhbnZhcy53aWR0aCAvIGV4cGVuc2VDYW52YXMuaGVpZ2h0O1xyXG4vLyAgICAgY29uc3QgZXhwZW5zZUhlaWdodCA9IGV4cGVuc2VXaWR0aCAvIGV4cGVuc2VBc3BlY3RSYXRpbztcclxuLy8gICAgIGRvYy5hZGRJbWFnZShleHBlbnNlSW1hZ2UsIFwiUE5HXCIsIDQwLCA0ODAsIGV4cGVuc2VXaWR0aCwgZXhwZW5zZUhlaWdodCk7XHJcbiAgXHJcbi8vICAgICAvLyBDYXB0dXJlIGFuZCBhZGQgYXNzZXRzIGNoYXJ0XHJcbi8vICAgICBjb25zdCBhc3NldHNDYW52YXMgPSBhd2FpdCBodG1sMmNhbnZhcyhhc3NldHNDaGFydFJlZi5jdXJyZW50KTtcclxuLy8gICAgIGNvbnN0IGFzc2V0c0ltYWdlID0gYXNzZXRzQ2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuLy8gICAgIGNvbnN0IGFzc2V0c1dpZHRoID0gNTAwO1xyXG4vLyAgICAgY29uc3QgYXNzZXRzQXNwZWN0UmF0aW8gPSBhc3NldHNDYW52YXMud2lkdGggLyBhc3NldHNDYW52YXMuaGVpZ2h0O1xyXG4vLyAgICAgY29uc3QgYXNzZXRzSGVpZ2h0ID0gYXNzZXRzV2lkdGggLyBhc3NldHNBc3BlY3RSYXRpbztcclxuLy8gICAgIGRvYy5hZGRJbWFnZShhc3NldHNJbWFnZSwgXCJQTkdcIiwgNDAsIDg4MCwgYXNzZXRzV2lkdGgsIGFzc2V0c0hlaWdodCk7XHJcbiAgXHJcbi8vICAgICAvLyBTYXZlIHRoZSBQREZcclxuLy8gICAgIGRvYy5zYXZlKFwiZmluYW5jaWFsX3JlcG9ydF8yMDIyLnBkZlwiKTtcclxuLy8gICB9O1xyXG4gIFxyXG5cclxuLy8gICByZXR1cm4gKFxyXG4vLyAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9PlxyXG4vLyAgICAgICA8aDEgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyfT5GaW5hbmNpYWwgRGFzaGJvYXJkPC9oMT5cclxuXHJcbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3VtbWFyeUNvbnRhaW5lcn0+XHJcbi8vICAgICAgICAgPGRpdj5cclxuLy8gICAgICAgICAgIDxoMz5Ub3RhbCBSZXZlbnVlICgyMDIyKTwvaDM+XHJcbi8vICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5yZXZlbnVlVGV4dH0+JHtkYXRhWzhdPy5bJzIwMjInXX08L3A+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgICAgPGRpdj5cclxuLy8gICAgICAgICAgIDxoMz5Ub3RhbCBFeHBlbnNlcyAoMjAyMik8L2gzPlxyXG4vLyAgICAgICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuZXhwZW5zZXNUZXh0fT4ke2RhdGFbNF0/LlsnMjAyMiBFeHBlbnNlcyddfTwvcD5cclxuLy8gICAgICAgICA8L2Rpdj5cclxuLy8gICAgICAgPC9kaXY+XHJcblxyXG4vLyAgICAgICB7LyogUmV2ZW51ZSBDaGFydCAqL31cclxuLy8gICAgICAgPHNlY3Rpb24+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT17c3R5bGVzLmNoYXJ0U2VjdGlvbn0+UmV2ZW51ZSBDb21wYXJpc29uIGJ5IFllYXI8L2gyPlxyXG4vLyAgICAgICAgIDxkaXYgcmVmPXtyZXZlbnVlQ2hhcnRSZWZ9IGNsYXNzTmFtZT17c3R5bGVzLmNoYXJ0Q29udGFpbmVyfT5cclxuLy8gICAgICAgICAgIDxCYXIgZGF0YT17cmV2ZW51ZURhdGF9IG9wdGlvbnM9e2Jhck9wdGlvbnN9IC8+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvc2VjdGlvbj5cclxuXHJcbi8vICAgICAgIHsvKiBFeHBlbnNlcyBDaGFydCAqL31cclxuLy8gICAgICAgPHNlY3Rpb24gc3R5bGU9e3sgbWFyZ2luVG9wOiAnMnJlbScgfX0+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT17c3R5bGVzLmNoYXJ0U2VjdGlvbn0+MjAyMiBFeHBlbnNlcyBEaXN0cmlidXRpb248L2gyPlxyXG4vLyAgICAgICAgIDxkaXYgcmVmPXtleHBlbnNlQ2hhcnRSZWZ9IGNsYXNzTmFtZT17c3R5bGVzLmNoYXJ0Q29udGFpbmVyfT5cclxuLy8gICAgICAgICAgICAgPFBpZSBkYXRhPXtleHBlbnNlRGF0YTIwMjJ9IG9wdGlvbnM9e2V4cGVuc2VPcHRpb25zfSAvPlxyXG4vLyAgICAgICAgIDwvZGl2PlxyXG4vLyAgICAgICA8L3NlY3Rpb24+XHJcblxyXG5cclxuLy8gICAgICAgey8qIEFzc2V0cyBDaGFydCAqL31cclxuLy8gICAgICAgPHNlY3Rpb24gc3R5bGU9e3sgbWFyZ2luVG9wOiAnMnJlbScgfX0+XHJcbi8vICAgICAgICAgPGgyIGNsYXNzTmFtZT17c3R5bGVzLmNoYXJ0U2VjdGlvbn0+QXNzZXRzIENvbXBhcmlzb24gYnkgWWVhcjwvaDI+XHJcbi8vICAgICAgICAgPGRpdiByZWY9e2Fzc2V0c0NoYXJ0UmVmfSBjbGFzc05hbWU9e3N0eWxlcy5jaGFydENvbnRhaW5lcn0+XHJcbi8vICAgICAgICAgICA8QmFyIGRhdGE9e2Fzc2V0c0RhdGF9IG9wdGlvbnM9e2Jhck9wdGlvbnN9IC8+XHJcbi8vICAgICAgICAgPC9kaXY+XHJcbi8vICAgICAgIDwvc2VjdGlvbj5cclxuXHJcbi8vICAgICAgIHsvKiBHZW5lcmF0ZSBSZXBvcnQgQnV0dG9uICovfVxyXG4vLyAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2dlbmVyYXRlUmVwb3J0fSBjbGFzc05hbWU9e3N0eWxlcy5nZW5lcmF0ZVJlcG9ydEJ1dHRvbn0+XHJcbi8vICAgICAgICAgR2VuZXJhdGUgUmVwb3J0XHJcbi8vICAgICAgIDwvYnV0dG9uPlxyXG4vLyAgICAgPC9kaXY+XHJcbi8vICAgKTtcclxuLy8gfVxyXG5cclxuXHJcblxyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/financial.js\n"));

/***/ })

});